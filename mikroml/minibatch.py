# AUTOGENERATED! DO NOT EDIT! File to edit: ../notebooks/04_minibatch.ipynb.

# %% auto 0
__all__ = ['accuracy', 'report', 'get_lin_model', 'Dataset', 'fit', 'get_dls']

# %% ../notebooks/04_minibatch.ipynb 34
def accuracy(preds:torch.tensor, targs:torch.tensor) -> float:
    """ The average of the correctly predicted numbers """
    return (preds.argmax(dim=1)==targs).float().mean()

# %% ../notebooks/04_minibatch.ipynb 36
def report(epoch:int, preds:torch.tensor, targs:torch.tensor, loss:float):
    """ Print a report after each epoch of training """
    print(f"epoch:{epoch} \t accuracy:{accuracy(preds, targs).item():.3f} \t loss:{loss.item():.5f}")

# %% ../notebooks/04_minibatch.ipynb 83
def get_lin_model():
    _model = nn.Sequential(nn.Linear(m, nh), nn.ReLU(), nn.Linear(nh, c))
    _opt = optim.SGD(_model.parameters(), lr=0.5)
    return _model, _opt

# %% ../notebooks/04_minibatch.ipynb 86
class Dataset():
    def __init__(self, x, y):
        self.x = x
        self.y = y
        
    def __len__(self):
        return len(self.x)
    
    def __getitem__(self, s):
        """ Slicing function: replaced slice() """
        return self.x[s], self.y[s]

# %% ../notebooks/04_minibatch.ipynb 123
from torch.utils.data import DataLoader, SequentialSampler, RandomSampler, BatchSampler

# %% ../notebooks/04_minibatch.ipynb 134
def fit(epochs, model, loss_func, opt, train_dl, valid_dl):
    for epoch in range(epochs):
        model.train()
        for xb, yb in train_dl:
            train_preds = model(xb)
            train_loss = loss_func(train_preds, yb)
            train_loss.backward()
            opt.step()
            opt.zero_grad()
        # Print training report
        report(epoch, train_preds, yb, train_loss)
        
        model.eval()
        with torch.no_grad():
            tot_loss,tot_acc,count = 0.,0.,0
            for xb, yb in valid_dl:
                valid_preds = model(xb)
                n = len(xb) # batch size?
                count += n # Why?
                tot_loss += loss_func(valid_preds, yb).item()*n # Why multiply?
                tot_acc += accuracy(valid_preds, yb)*n
        print(f"epoch:{epoch}\t valid accuracy: {tot_acc/count:.3}\t valid loss: {tot_loss/count:.3}")
    return tot_loss/count, tot_acc/count

# %% ../notebooks/04_minibatch.ipynb 135
def get_dls(train_ds, valid_ds, bs, **kwargs):
    train_dl = DataLoader(train_ds, bs, shuffle=True, drop_last=True, num_workers=2, **kwargs)
    valid_dl = DataLoader(valid_ds, bs, shuffle=False, num_workers=2, **kwargs)
    return(train_dl, valid_dl)
